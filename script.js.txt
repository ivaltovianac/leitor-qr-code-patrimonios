/**
 * ==== Leitor de Qr Codes Patrimônios ====
 * Sistema para leitura de QR Codes patrimoniais
 * com funcionalidades de exportação para Excel e PDF
 * e persistência via localStorage
 */

// Variáveis globais do sistema
let html5QrCode = null; // Instância do leitor de QR Code
let isScanning = false; // Estado atual da câmera (ativa/inativa)
let patrimonioData = []; // Array com todos os patrimônios escaneados
let editModal = null;   // Referência ao modal de edição

// Configurações de paginação da tabela de patrimônios
const itemsPerPage = 5; // Número de itens exibidos por página
let currentPage = 1; // Página atual da tabela
let searchTerm = ''; // Termo de busca para filtrar patrimônios

// Objeto com referências aos elementos HTML do DOM sem múltiplas chamadas getElementById
const elements = {
    startBtn: document.getElementById('startBtn'), // Botão para iniciar a câmera
    stopBtn: document.getElementById('stopBtn'), // Botão para parar a câmera
    clearBtn: document.getElementById('clearBtn'), // Botão para limpar todos os dados
    exportExcelBtn: document.getElementById('exportExcelBtn'), // Botão para exportar para Excel
    exportPdfBtn: document.getElementById('exportPdfBtn'), // Botão para exportar para PDF
    dataTableBody: document.getElementById('dataTableBody'), // Corpo da tabela de patrimônios
    totalItems: document.getElementById('totalItems'), // Elemento que exibe o total de itens
    alertContainer: document.getElementById('alertContainer'), // Container para exibir alertas
    editModal: document.getElementById('editModal'), // Modal de edição de patrimônio
    editForm: document.getElementById('editForm'), // Formulário de edição
    saveEditBtn: document.getElementById('saveEditBtn'), // Botão para salvar edição
    searchInput: document.getElementById('searchInput') // Campo de busca/filtro
};

// Inicialização do sistema quando o DOM estiver completamente carregado
document.addEventListener('DOMContentLoaded', function () {
    loadDataFromStorage(); // Carrega dados salvos do localStorage
    editModal = new bootstrap.Modal(elements.editModal); // Inicializa modal de edição
    setupEventListeners(); // Configura todos os eventos de clique e interação
    checkCameraSupport(); // Verifica se o navegador suporta câmera
    updateUI(); // Atualiza interface com dados carregados
    updateTable(); // Renderiza tabela de patrimônios
    setupResponsiveTable(); // Configura responsividade da tabela
    showAlert('Sistema iniciado com sucesso!', 'success'); // Exibe mensagem de sucesso
});

// Persistência
// Salva os dados de patrimônio no localStorage do navegador
function saveDataToStorage() {
    localStorage.setItem('patrimonioData', JSON.stringify(patrimonioData));
}

// Carrega os dados salvos do localStorage e garante que cada item tenha um ID único
function loadDataFromStorage() {
    const saved = localStorage.getItem('patrimonioData');
    if (saved) {
        try {
            // Converte string JSON em array de objetos
            patrimonioData = JSON.parse(saved);
            // Garante que todos os itens tenham um ID único para edição/exclusão
            patrimonioData.forEach(item => {
                if (item.id === undefined) item.id = Date.now() + Math.random();
            });
        } catch (e) {
            // Em caso de erro na leitura, inicializa array vazio
            console.error('Erro ao carregar dados', e);
            patrimonioData = [];
        }
    }
}

// Configura todos os eventos de clique e interação dos botões e formulários
function setupEventListeners() {
    // Botões de controle da câmera
    elements.startBtn.addEventListener('click', startScanning);
    elements.stopBtn.addEventListener('click', stopScanning);

    // Botões de gerenciamento de dados
    elements.clearBtn.addEventListener('click', clearData);
    elements.exportExcelBtn.addEventListener('click', exportToExcel);
    elements.exportPdfBtn.addEventListener('click', exportToPDF);

    // Botão de salvar edição no modal
    elements.saveEditBtn.addEventListener('click', saveEdit);

    // Campo de busca/filtro na tabela
    elements.searchInput.addEventListener('input', handleSearch);

    // Evento para fechar alertas clicando no botão X
    document.addEventListener('click', function (e) {
        if (e.target.classList.contains('btn-close')) {
            e.target.closest('.alert').remove();
        }
    });

    // Formulário de adição manual de patrimônio
    document.getElementById('manualAddForm').addEventListener('submit', handleManualAdd);
}

// Processa adição manual de patrimônio através do formulário
// Valida campos obrigatórios e adiciona novo registro à tabela
function handleManualAdd(event) {
    event.preventDefault();
    const patrimonio = document.getElementById('inputPatrimonio').value.trim();
    const item = document.getElementById('inputItem').value.trim();
    const coordenacao = document.getElementById('inputCoordenacao').value.trim();
    const servidor = document.getElementById('inputServidor').value.trim();
    const coordenador = document.getElementById('inputCoordenador').value.trim();

    // Valida se todos os campos foram preenchidos
    if (!patrimonio || !item || !coordenacao || !servidor || !coordenador) {
        showAlert('Preencha todos os campos.', 'warning');
        return;
    }

    /* Cria objeto com os dados do novo patrimônio
        Gera ID único usando timestamp + número aleatório para evitar duplicatas
        dataHora registra momento exato da adição no formato brasileiro */
    const newData = {
        patrimonio,
        item,
        coordenacao,
        servidor,
        coordenador,
        dataHora: new Date().toLocaleString('pt-BR'),
        id: Date.now() + Math.random()
    };

    // Adiciona patrimônio e limpa formulário
    addPatrimonioData(newData);
    event.target.reset();
    showAlert('Dados adicionados manualmente!', 'success');
}

// Scanner
function checkCameraSupport() {
    // Verifica se o navegador possui suporte para acessar dispositivos de mídia (câmera)
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showAlert('Seu navegador não suporta acesso à câmera.', 'danger');
        elements.startBtn.disabled = true;
        return false;
    }
    // Retorna true se o navegador suporta câmera
    return true;
}

// Inicia o scanner de QR Code usando a câmera do dispositivo
async function startScanning() {
    // Evita iniciar múltiplas instâncias do scanner
    if (isScanning) return;
    try {
        // Configurações do scanner: FPS, tamanho da área de leitura e qualidade de vídeo
        const config = {
            fps: 10,
            qrbox: { width: 250, height: 250 },
            aspectRatio: 1.0,
            disableFlip: false,
            videoConstraints: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                facingMode: "environment",
                advanced: [{ focusMode: "continuous" }]
            }
        };

        // Inicializa o scanner e começa a capturar vídeo da câmera traseira
        html5QrCode = new Html5Qrcode("qr-reader");
        await html5QrCode.start(
            { facingMode: "environment" },
            config,
            onScanSuccess,
            onScanFailure
        );
        // Atualiza estado e interface para indicar que o scanner está ativo
        isScanning = true;
        updateScannerUI(true);
        document.getElementById('cameraStatus').textContent = 'Conectado';
        document.getElementById('cameraStatus').className = 'camera-status connected';
        showAlert('Scanner iniciado!', 'success');
    } catch (error) {
        // Trata erros de acesso à câmera (permissão negada, câmera indisponível, etc)
        console.error('Erro ao iniciar scanner:', error);
        let msg = 'Erro ao acessar câmera.';
        if (error.message.includes('Permission denied')) msg = 'Permissão de câmera negada.';
        showAlert(msg, 'danger');
        updateScannerUI(false);
        document.getElementById('cameraStatus').textContent = 'Erro';
        document.getElementById('cameraStatus').className = 'camera-status disconnected';
    }
}

// Para a leitura do QR Code e desconecta a câmera
async function stopScanning() {
    // Verifica se o scanner está ativo antes de parar
    if (!isScanning || !html5QrCode) return;

    try {
        // Para a leitura da câmera e limpa o scanner
        await html5QrCode.stop();
        html5QrCode.clear();
        html5QrCode = null;
        isScanning = false;

        // Atualiza a interface para refletir o estado desconectado
        updateScannerUI(false);
        document.getElementById('cameraStatus').textContent = 'Desconectado';
        document.getElementById('cameraStatus').className = 'camera-status disconnected';
        showAlert('Scanner parado.', 'info');
    } catch (error) {
        // Trata erros ao tentar parar o scanner
        console.error('Erro ao parar scanner:', error);
        showAlert('Erro ao parar scanner.', 'warning');
    }
}

// Função chamada quando um QR Code é lido com sucesso
function onScanSuccess(decodedText) {
    // Processa o texto do QR Code e extrai os dados do patrimônio
    const parsedData = parseQRCodeData(decodedText);

    // Se os dados forem válidos, adiciona à lista e notifica o usuário
    if (parsedData) {
        addPatrimonioData(parsedData);
        showAlert(`QR Code lido: ${parsedData.patrimonio}`, 'success');
        // Vibra o dispositivo para feedback tátil (se disponível)
        if (navigator.vibrate) navigator.vibrate(200);
    } else {
        // Notifica o usuário caso o QR Code não seja válido
        showAlert('QR Code inválido.', 'warning');
    }
}

// Função chamada quando há falha na leitura do QR Code
// Mantida silenciosa para não poluir o console com erros de leitura contínua
function onScanFailure(error) {

}

// Função que processa o texto do QR Code e extrai os dados do patrimônio
// Retorna um objeto com os dados extraídos ou null se houver erro ou dados incompletos
function parseQRCodeData(qrText) {
    try {
        // Divide o texto em linhas e remove espaços em branco
        const lines = qrText.split('\n').map(l => l.trim()).filter(l => l);
        const data = {};

        // Percorre cada linha buscando os campos esperados
        for (const line of lines) {
            if (line.startsWith('Patrimônio:')) data.patrimonio = line.split('Patrimônio:')[1].trim();
            else if (line.startsWith('Item:')) data.item = line.split('Item:')[1].trim();
            else if (line.startsWith('Coordenação:')) data.coordenacao = line.split('Coordenação:')[1].trim();
            else if (line.includes('Servidor') && line.includes(':')) data.servidor = line.split(':')[1].trim();
            else if (line.startsWith('Coordenador:')) data.coordenador = line.split('Coordenador:')[1].trim();
        }

        // Valida se todos os campos obrigatórios foram encontrados
        if (data.patrimonio && data.item && data.coordenacao && data.servidor && data.coordenador) {
            data.dataHora = new Date().toLocaleString('pt-BR');
            data.id = Date.now() + Math.random();
            return data;
        }
        return null;
    } catch (e) {
        return null;
    }
}

// Adiciona novo patrimônio ao sistema, verificando duplicatas antes de inserir
function addPatrimonioData(data) {
    // Verifica se o patrimônio já existe na lista
    const exists = patrimonioData.find(item =>
        item.patrimonio === data.patrimonio && item.item === data.item
    );
    if (exists) {
        showAlert(`Patrimônio ${data.patrimonio} já registrado.`, 'warning');
        return;
    }
    // Adiciona o novo patrimônio e atualiza o sistema
    patrimonioData.push(data);
    saveDataToStorage();
    updateTable();
    updateUI();
}

// Atualiza o estado dos botões de controle do scanner (ativa/desativa conforme o estado de escaneamento)
function updateScannerUI(scanning) {
    elements.startBtn.disabled = scanning;
    elements.stopBtn.disabled = !scanning;
}

// Realiza a busca na tabela de patrimônios filtrando pelos termos digitados
function handleSearch() {
    searchTerm = elements.searchInput.value.toLowerCase();
    currentPage = 1;
    updateTable();
}

// Atualiza a tabela de patrimônios com filtros de busca e paginação
// Renderiza as linhas da tabela com os dados filtrados e aplica responsividade para telas pequenas
function updateTable() {
    // Filtra os dados baseado no termo de busca
    let filtered = patrimonioData;
    if (searchTerm) {
        filtered = patrimonioData.filter(item =>
            Object.values(item).some(val =>
                typeof val === 'string' && val.toLowerCase().includes(searchTerm)
            )
        );
    }

    // Calcula a paginação dos dados filtrados
    const total = filtered.length;
    const start = (currentPage - 1) * itemsPerPage;
    const end = start + itemsPerPage;
    const pageData = filtered.slice(start, end);

    // Renderiza as linhas da tabela
    elements.dataTableBody.innerHTML = '';
    pageData.forEach((item, idx) => {
        const row = document.createElement('tr');
        row.className = 'fade-in new-row';
        const globalIndex = start + idx + 1;

        // Verificar se estamos em uma tela pequena para aplicar dtr-control
        const isSmallScreen = window.innerWidth < 576;

        // Monta o HTML da linha com todos os dados do patrimônio
        row.innerHTML = `
            <td class="${isSmallScreen ? 'dtr-control' : ''}" data-label="Nº" ${isSmallScreen ? 'onclick="toggleRowDetails(this)"' : ''}>
                <strong>${globalIndex}</strong>
            </td>
            <td data-label="Patrimônio"><span class="badge bg-primary">${item.patrimonio}</span></td>
            <td data-label="Item">${item.item}</td>
            <td data-label="Coordenação"><span class="badge bg-secondary">${item.coordenacao}</span></td>
            <td data-label="Servidor(a)">${item.servidor}</td>
            <td data-label="Coordenador">${item.coordenador}</td>
            <td data-label="Data/Hora"><small class="text-muted">${item.dataHora}</small></td>
            <td data-label="Ações">
                <button class="btn btn-sm btn-outline-primary action-btn" onclick="editItem(${patrimonioData.indexOf(item)})" title="Editar">
                    <i class="bi bi-pencil"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger action-btn" onclick="deleteItem(${patrimonioData.indexOf(item)})" title="Excluir">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        `;
        elements.dataTableBody.appendChild(row);
        setTimeout(() => row.classList.remove('new-row'), 500);
    });

    // Atualiza os controles de paginação
    renderPagination(total);
}

// Função para expandir/recolher detalhes da linha em telas pequenas
function toggleRowDetails(element) {
    const row = element.closest('tr');
    const isExpanded = element.classList.contains('expanded');

    if (isExpanded) {
        // Recolher detalhes
        element.classList.remove('expanded');
        const details = row.querySelector('.dtr-details');
        if (details) details.remove();
    } else {
        // Expandir detalhes
        element.classList.add('expanded');

        // Remover qualquer detalhe existente
        const existingDetails = row.querySelector('.dtr-details');
        if (existingDetails) existingDetails.remove();

        // Criar novo elemento de detalhes
        const details = document.createElement('div');
        details.className = 'dtr-details';

        // Obter dados da linha
        const cells = row.querySelectorAll('td');
        const labels = ['Patrimônio', 'Item', 'Coordenação', 'Servidor(a)', 'Coordenador', 'Data/Hora'];

        // Adicionar detalhes (pular primeira célula que é o número e última que são ações)
        for (let i = 1; i < cells.length - 1; i++) {
            const detailRow = document.createElement('div');
            detailRow.className = 'dtr-details-row';
            detailRow.innerHTML = `
                <span class="dtr-title">${labels[i - 1]}:</span>
                <span class="dtr-data">${cells[i].innerHTML}</span>
            `;
            details.appendChild(detailRow);
        }

        // Adicionar detalhes após a linha
        row.parentNode.insertBefore(details, row.nextSibling);
    }
}

// Configurar tabela responsiva baseada no tamanho da tela
function setupResponsiveTable() {
    // Adicionar evento de redimensionamento para atualizar a tabela
    window.addEventListener('resize', function () {
        updateTable();
    });
}

// Renderiza os controles de paginação da tabela
// Cria botões de navegação entre páginas com indicadores visuais
function renderPagination(totalItems) {
    const totalPages = Math.ceil(totalItems / itemsPerPage);
    const container = document.getElementById('paginationControls');
    container.innerHTML = '';

    // Não exibe paginação se houver apenas uma página
    if (totalPages <= 1) return;

    // Função auxiliar para criar botões de paginação
    const createButton = (text, page, disabled = false, active = false) => {
        const li = document.createElement('li');
        li.className = `page-item ${disabled ? 'disabled' : ''} ${active ? 'active' : ''}`;
        const btn = document.createElement('button');
        btn.className = 'page-link';
        btn.textContent = text;
        if (!disabled) btn.onclick = () => { currentPage = page; updateTable(); };
        li.appendChild(btn);
        return li;
    };

    // Botão anterior
    container.appendChild(createButton('«', Math.max(1, currentPage - 1), currentPage === 1));

    // Primeira página
    container.appendChild(createButton('1', 1, false, currentPage === 1));

    // Reticências antes da página atual
    if (currentPage > 3) {
        const li = document.createElement('li');
        li.className = 'page-item disabled';
        li.innerHTML = '<span class="page-link">...</span>';
        container.appendChild(li);
    }

    // Páginas ao redor da página atual
    for (let i = Math.max(2, currentPage - 1); i <= Math.min(totalPages - 1, currentPage + 1); i++) {
        container.appendChild(createButton(i, i, false, i === currentPage));
    }

    // Reticências depois da página atual
    if (currentPage < totalPages - 2) {
        const li = document.createElement('li');
        li.className = 'page-item disabled';
        li.innerHTML = '<span class="page-link">...</span>';
        container.appendChild(li);
    }

    // Última página
    if (totalPages > 1) {
        container.appendChild(createButton(totalPages, totalPages, false, currentPage === totalPages));
    }

    // Botão próximo
    container.appendChild(createButton('»', Math.min(totalPages, currentPage + 1), currentPage === totalPages));
}

// Atualiza a interface do usuário com contadores e estados dos botões
function updateUI() {
    const hasData = patrimonioData.length > 0;
    elements.totalItems.textContent = patrimonioData.length;
    elements.clearBtn.disabled = !hasData;
    elements.exportExcelBtn.disabled = !hasData;
    elements.exportPdfBtn.disabled = !hasData;
    if (hasData) {
        elements.exportExcelBtn.innerHTML = `<i class="bi bi-file-earmark-excel"></i> Exportar Excel (${patrimonioData.length})`;
        elements.exportPdfBtn.innerHTML = `<i class="bi bi-file-earmark-pdf"></i> Exportar PDF (${patrimonioData.length})`;
    }
}

// Abre o modal de edição preenchido com os dados do item selecionado
function editItem(index) {
    const item = patrimonioData[index];
    if (!item) return;
    document.getElementById('editIndex').value = index;
    document.getElementById('editPatrimonio').value = item.patrimonio;
    document.getElementById('editItem').value = item.item;
    document.getElementById('editCoordenacao').value = item.coordenacao;
    document.getElementById('editServidor').value = item.servidor;
    document.getElementById('editCoordenador').value = item.coordenador;
    editModal.show();
}

// Salva as alterações feitas no item editado
function saveEdit() {
    const index = parseInt(document.getElementById('editIndex').value);
    if (isNaN(index) || index < 0 || index >= patrimonioData.length) return;

    const form = elements.editForm;
    if (!form.checkValidity()) {
        form.reportValidity();
        return;
    }

    patrimonioData[index] = {
        ...patrimonioData[index],
        patrimonio: document.getElementById('editPatrimonio').value.trim(),
        item: document.getElementById('editItem').value.trim(),
        coordenacao: document.getElementById('editCoordenacao').value.trim(),
        servidor: document.getElementById('editServidor').value.trim(),
        coordenador: document.getElementById('editCoordenador').value.trim()
    };

    saveDataToStorage();
    updateTable();
    editModal.hide();
    showAlert('Dados atualizados!', 'success');
}

// Remove um item da lista após confirmação do usuário
function deleteItem(index) {
    if (confirm('Tem certeza que deseja excluir este item?')) {
        const item = patrimonioData[index];
        patrimonioData.splice(index, 1);
        saveDataToStorage();
        currentPage = 1;
        updateTable();
        updateUI();
        showAlert(`Item ${item.patrimonio} removido.`, 'info');
    }
}

//  EXPORTAÇÃO
async function exportToExcel() {
    if (patrimonioData.length === 0) {
        showAlert('Não há dados para exportar.', 'warning');
        return;
    }

    try {
        const hoje = new Date();
        const meses = [
            'janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho',
            'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'
        ];
        const dataFormatada = `${hoje.getDate()} de ${meses[hoje.getMonth()]} de ${hoje.getFullYear()} às ${String(hoje.getHours()).padStart(2, '0')}:${String(hoje.getMinutes()).padStart(2, '0')}`;

        const workbook = new ExcelJS.Workbook();
        const sheet = workbook.addWorksheet('Patrimônio');

        // Título institucional
        sheet.mergeCells('A1:G1');
        // sheet.getCell('A1').value = `Relatório de Patrimônio - ${hoje.toLocaleDateString('pt-BR')}`;
        sheet.getCell('A1').value = `Relatório de Patrimônios`;
        sheet.getCell('A1').font = { bold: true, size: 14, color: { argb: 'FFFFFF' } };
        sheet.getCell('A1').alignment = { horizontal: 'center' };
        sheet.getCell('A1').fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: '0D6EFD' } };

        sheet.mergeCells('A2:G2');
        sheet.getCell('A2').value = `Gerado em: ${dataFormatada}`;
        sheet.getCell('A2').font = { bold: true, color: { argb: 'FFFFFF' } };
        sheet.getCell('A2').alignment = { horizontal: 'center' };
        sheet.getCell('A2').fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: '0D6EFD' } };

        sheet.mergeCells('A3:G3');
        sheet.getCell('A3').value = `Total de itens: ${patrimonioData.length}`;
        sheet.getCell('A3').font = { bold: true, color: { argb: 'FFFFFF' } };
        sheet.getCell('A3').alignment = { horizontal: 'center' };
        sheet.getCell('A3').fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: '0D6EFD' } };

        // Cabeçalho
        const header = ['Nº', 'Patrimônio', 'Item', 'Coordenação', 'Servidor(a)', 'Coordenador', 'Data/Hora'];
        sheet.addRow([]);
        sheet.addRow(header);
        const headerRow = sheet.getRow(5);
        headerRow.eachCell(cell => {
            cell.font = { bold: true, color: { argb: 'FFFFFF' } };
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: '4F81BD' } };
            cell.alignment = { horizontal: 'center' };
            cell.border = {
                top: { style: 'thin' },
                bottom: { style: 'thin' },
                left: { style: 'thin' },
                right: { style: 'thin' }
            };
        });

        // Dados
        patrimonioData.forEach((item, i) => {
            const row = sheet.addRow([
                i + 1,
                item.patrimonio,
                item.item,
                item.coordenacao,
                item.servidor,
                item.coordenador,
                item.dataHora
            ]);
            const bgColor = i % 2 === 0 ? 'E9EDF5' : 'FFFFFF';
            row.eachCell(cell => {
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: bgColor } };
                cell.alignment = { horizontal: 'left' };
                cell.border = {
                    top: { style: 'thin' },
                    bottom: { style: 'thin' },
                    left: { style: 'thin' },
                    right: { style: 'thin' }
                };
            });
        });

        // Largura das colunas
        const widths = [6, 12, 35, 18, 22, 22, 20];
        widths.forEach((w, i) => sheet.getColumn(i + 1).width = w);

        // Filtro automático
        sheet.autoFilter = {
            from: 'A5',
            to: `G${sheet.rowCount}`
        };

        // Congelamento do cabeçalho
        sheet.views = [{ state: 'frozen', xSplit: 0, ySplit: 5 }];

        // Exportar
        const buffer = await workbook.xlsx.writeBuffer();
        const blob = new Blob([buffer], {
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `patrimonio_${hoje.getFullYear()}${String(hoje.getMonth() + 1).padStart(2, '0')}${String(hoje.getDate()).padStart(2, '0')}_${String(hoje.getHours()).padStart(2, '0')}${String(hoje.getMinutes()).padStart(2, '0')}.xlsx`;
        link.click();

        showAlert(`✅ Arquivo Excel exportado com sucesso`, 'success');

    } catch (e) {
        console.error('❌ Erro detalhado ao exportar Excel:', e);
        showAlert('❌ Erro ao exportar Excel. Verifique o console para detalhes.', 'danger');
    }
}

function exportToPDF() {
    if (patrimonioData.length === 0) return showAlert('Não há dados para exportar.', 'warning');
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;

        // Logo
        const logoBase64 = ''; // <<< Insira aqui o base64 da imagem do brasão

        // Adiciona logo centralizada no topo
        const logoWidth = 20.37; // 77px ≈ 20.37mm
        const logoHeight = 20.37;
        doc.addImage(logoBase64, 'PNG', (pageWidth - logoWidth) / 2, 10, logoWidth, logoHeight);

        let y = 10 + logoHeight + 5;

        // Cabeçalho moderno
        doc.setFontSize(18);
        doc.setFont(undefined, 'bold');
        doc.setTextColor(40);
        doc.text('Relatório de Patrimônios', pageWidth / 2, y, { align: 'center' });

        y += 10;
        doc.setFontSize(10);
        doc.setFont(undefined, 'normal');
        const hoje = new Date();
        const meses = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
        const dataFormatada = `${hoje.getDate()} de ${meses[hoje.getMonth()]} de ${hoje.getFullYear()} às ${String(hoje.getHours()).padStart(2, '0')}:${String(hoje.getMinutes()).padStart(2, '0')}`;
        doc.text(`Gerado em: ${dataFormatada}`, pageWidth / 2, y, { align: 'center' });

        y += 5;
        doc.text(`Total de itens: ${patrimonioData.length}`, pageWidth / 2, y, { align: 'center' });

        y += 10;

        // Tabela
        const headers = ['Nº', 'Patrimônio', 'Item', 'Coordenação', 'Servidor(a)', 'Coordenador'];
        const colWidths = [10, 25, 55, 25, 35, 35];
        const lineHeight = 6;

        doc.setFontSize(9);
        doc.setFont(undefined, 'bold');
        let x = margin;

        headers.forEach((h, i) => {
            doc.text(h, x, y);
            x += colWidths[i];
        });

        y += 6;
        doc.setDrawColor(200);
        doc.line(margin, y, pageWidth - margin, y);
        y += 4;

        doc.setFont(undefined, 'normal');

        patrimonioData.forEach((item, idx) => {
            // Prepara as células com quebra de texto
            const cells = [
                String(idx + 1),
                item.patrimonio,
                item.item,
                item.coordenacao,
                item.servidor,
                item.coordenador
            ];

            // Divide cada célula conforme a largura da coluna
            const splitCells = cells.map((text, i) =>
                doc.splitTextToSize(text, colWidths[i] - 2) // margem interna pequena
            );

            // Determina a altura da linha com base na célula com mais linhas
            const maxLines = Math.max(...splitCells.map(lines => lines.length), 1);
            const rowHeight = maxLines * lineHeight;

            // Verifica se há espaço suficiente na página atual
            if (y + rowHeight > pageHeight - 20) {
                doc.addPage();
                y = margin;
                let x = margin;
                doc.setFont(undefined, 'bold');
                headers.forEach((h, i) => {
                    doc.text(h, x, y);
                    x += colWidths[i];
                });
                y += 6;
                doc.setDrawColor(200);
                doc.line(margin, y, pageWidth - margin, y);
                y += 4;
                doc.setFont(undefined, 'normal');
            }

            // Escreve cada célula linha por linha
            let x = margin;
            for (let i = 0; i < splitCells.length; i++) {
                const lines = splitCells[i];
                for (let j = 0; j < lines.length; j++) {
                    doc.text(lines[j], x, y + (j * lineHeight));
                }
                x += colWidths[i];
            }

            y += rowHeight;
        });

        // Rodapé com paginação
        const totalPages = doc.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
            doc.setPage(i);
            doc.setFontSize(8);
            doc.setTextColor(120);
            doc.text(`Página ${i} de ${totalPages}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
        }

        // Nome do arquivo
        const fileName = `patrimonio_${hoje.getFullYear()}${String(hoje.getMonth() + 1).padStart(2, '0')}${String(hoje.getDate()).padStart(2, '0')}_${String(hoje.getHours()).padStart(2, '0')}${String(hoje.getMinutes()).padStart(2, '0')}.pdf`;
        doc.save(fileName);
        showAlert(`Arquivo PDF exportado: ${fileName}`, 'success');
    } catch (e) {
        showAlert('Erro ao exportar PDF.', 'danger');
    }
}


// Limpa todos os dados de patrimônio armazenados após confirmação do usuário
function clearData() {
    if (patrimonioData.length === 0) return;
    if (confirm(`Limpar todos os ${patrimonioData.length} itens? Esta ação não pode ser desfeita.`)) {
        patrimonioData = [];
        saveDataToStorage();
        currentPage = 1;
        updateTable();
        updateUI();
        showAlert('Dados limpos com sucesso.', 'info');
    }
}

function showAlert(message, type = 'info') {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
    alertDiv.innerHTML = `
        <i class="bi bi-${getAlertIcon(type)}"></i> ${message}
        <button type="button" class="btn-close" aria-label="Close"></button>
    `;
    elements.alertContainer.appendChild(alertDiv);
    setTimeout(() => alertDiv.remove(), 5000);
}

function getAlertIcon(type) {
    const icons = {
        success: 'check-circle',
        danger: 'exclamation-triangle',
        warning: 'exclamation-triangle',
        info: 'info-circle'
    };
    return icons[type] || 'info-circle';
}

const footerText = document.getElementById('footerText');
const hoje = new Date();
const ano = hoje.getFullYear();
footerText.innerHTML = `<i class="bi bi-c-circle"></i> ${ano} Todos os direitos reservados SUCAP/COSP.`;


// --- Início da integração do gerador de QR Code ---

function setupQRCodeGenerator() {
    const canvas = document.getElementById('qrcode');
    if (!canvas) {
        console.error('Canvas não encontrado!');
        return;
    }

    const ctx = canvas.getContext('2d');
    const input = document.getElementById('qr-text');
    const btn = document.getElementById('generate-btn');
    const downloadBtn = document.getElementById('download-btn');
    const status = document.getElementById('status');
    const colorPicker = document.getElementById('color-picker');

    // Verificar se todos os elementos existem
    if (!input || !btn || !downloadBtn || !status || !colorPicker) {
        console.error('Elementos do QR Code não encontrados!');
        return;
    }

    let qrColor = '#FFD700';

    // Limpar o canvas inicialmente
    function clearCanvas() {
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function gerarQRCode(texto) {
        status.textContent = '';

        // Limpar espaços em branco do texto
        const textoLimpo = texto.trim();

        if (!textoLimpo) {
            status.style.color = 'red';
            status.textContent = 'Digite algum texto para gerar o QR Code.';
            clearCanvas();
            return;
        }

        try {
            clearCanvas();

            // Verificar se a biblioteca QRCode está disponível
            if (typeof QRCode === 'undefined') {
                status.style.color = 'red';
                status.textContent = 'Biblioteca QRCode não carregada.';
                return;
            }

            // Usar a API correta da biblioteca
            QRCode.toCanvas(canvas, textoLimpo, {
                width: canvas.width,
                margin: 1,
                color: {
                    dark: qrColor,
                    light: '#FFFFFF'
                },
                errorCorrectionLevel: 'M'
            }, function (error) {
                if (error) {
                    console.error('Erro ao gerar QR:', error);
                    status.style.color = 'red';
                    status.textContent = 'Erro ao gerar QR Code.';
                    // Tentar método alternativo
                    tentarGerarQRCodeAlternativo(textoLimpo);
                    return;
                }
                status.style.color = 'green';
                status.textContent = 'QR Code gerado com sucesso!';
            });

        } catch (err) {
            console.error('Erro capturado:', err);
            status.style.color = 'red';
            status.textContent = 'Erro inesperado ao gerar QR Code.';
        }
    }

    // Método alternativo caso o principal falhe
    function tentarGerarQRCodeAlternativo(texto) {
        try {
            // Limpar e tentar método mais simples
            clearCanvas();

            QRCode.toCanvas(texto, {
                width: canvas.width,
                color: {
                    dark: qrColor,
                    light: '#FFFFFF'
                }
            }, function (err, canvasElement) {
                if (err) {
                    console.error('Erro no método alternativo:', err);
                    status.style.color = 'red';
                    status.textContent = 'Falha ao gerar QR Code.';
                    return;
                }

                // Desenhar o canvas gerado no nosso canvas
                ctx.drawImage(canvasElement, 0, 0);
                status.style.color = 'green';
                status.textContent = 'QR Code gerado com sucesso!';
            });
        } catch (err) {
            console.error('Erro no método alternativo:', err);
            status.style.color = 'red';
            status.textContent = 'Erro crítico ao gerar QR Code.';
        }
    }

    // Event Listeners
    btn.addEventListener('click', () => {
        gerarQRCode(input.value);
    });

    downloadBtn.addEventListener('click', () => {
        try {
            const dataUrl = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = 'qrcode-patrimonio.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            status.style.color = 'blue';
            status.textContent = 'QR Code baixado com sucesso!';

        } catch (err) {
            console.error('Erro ao baixar:', err);
            status.style.color = 'red';
            status.textContent = 'Erro ao baixar imagem.';
        }
    });

    colorPicker.addEventListener('input', (e) => {
        qrColor = e.target.value;
        if (input.value.trim()) {
            gerarQRCode(input.value);
        }
    });

    // Gerar QR Code inicial apenas se houver texto
    setTimeout(() => {
        if (input.value.trim()) {
            gerarQRCode(input.value);
        }
    }, 100);
}

// Inicializar quando o DOM estiver pronto
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM Carregado - Inicializando gerador de QR Code...');
    setupQRCodeGenerator();
});

// Verificar se há erros globais
window.addEventListener('error', function (e) {
    console.error('Erro global:', e.error);
});